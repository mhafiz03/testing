<!DOCTYPE html>
<html lang="en">

<head>
    <title>Tugas Magang GCS</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <script src="cuboi.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
        }

        canvas {
            width: 300px;
            height: 300px;
            border: #fff solid;
        }

        #map {
            height: 100vh;
            position: relative;
        }

        #navbar {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #333;
            opacity: 80%;
            padding: 10px;
            color: white;
            text-align: center;
            width: 500px;
            border-radius: 30px;
            z-index: 1002;
        }

        .absolute-button {
            position: absolute;
            font-size: medium;
            z-index: 1000;
            padding: 5px 10px 5px 10px;
            width: 20vh;
            background-color: #007BFF;
            color: white;
            border-radius: 10px;
            cursor: pointer;
            border: none;
        }

        .floating-menu {
            position: absolute;
            opacity: 80%;
            padding: 20px;
            background-color: #333;
            border: 1px solid #ccc;
            /* box-shadow: 0 0 10px rgba(0, 0, 0, 0.2); */
            z-index: 1001;
        }

        #hud-button {
            top: 10px;
            left: 10px;
        }

        #hud-menu {
            top: 60px;
            left: 10px;
            height: 70vh;
            width: 250px;
            border-radius: 0px 20px 20px 20px;
            align-items: center;
            color: #fff;
        }

        #connection-button {
            top: 10px;
            right: 10px;
        }

        #connection-menu {
            top: 60px;
            right: 10px;
            height: 60vh;
            width: 200px;
            border-radius: 20px 0px 20px 20px;
        }

        .label {
            font-weight: bold;
            margin-bottom: 5px;
            color: #fff;
        }

        #menu-button {
            bottom: 10px;
            right: 10px;
        }

        #main-menu {
            position: fixed;
            top: 50%;
            left: 50%;
            height: 60vh;
            transform: translate(-50%, -50%);
            width: 100vh;
            border-radius: 20px;
            align-items: center;
            justify-content: center;
            flex-direction: column;
        }

        #stats-menu {
            position: absolute;
            z-index: 1000;
            color: #fff;
            text-shadow:
                -1px -1px 0 #000,
                /* Top left */
                1px -1px 0 #000,
                /* Top right */
                -1px 1px 0 #000,
                /* Bottom left */
                1px 1px 0 #000;
            /* Bottom right */
            font-style: italic;
            font-size: medium;
            padding: 5px 20px;
            border-radius: 10px;
            bottom: 10px;
            left: 10px;
        }

        th,
        td {
            padding: 2px 2px;
            text-align: center;
        }

        #stats-menu table {
            width: 120%;
            height: 80%;
            border-collapse: collapse;
            /* margin-top: 10px; */
        }

        #hud-menu table {
            width: 100%;
            height: 40vh;
            border-collapse: collapse;
            margin-top: 30px;
        }

        #cam {
            /* max-height: 500px; */
            width: 100%;
        }

        #uav-mode {
            font-weight: bolder;
            color: yellow;
        }

        #uav-status {
            font-weight: bolder;
            color: red;
        }

        .input-box {
            width: 100%;
            box-sizing: border-box;
            margin-bottom: 10px;
        }

        #button-connect {
            padding: 8px;
            cursor: pointer;
            background-color: #007BFF;
            color: white;
            border: none;
            width: 100%;
            box-sizing: border-box;
            margin-bottom: 10px;
        }

        #log-box {
            width: 100%;
            height: 100px;
            box-sizing: border-box;
        }
    </style>
</head>

<body>
    <div id="navbar"><span style="font-size: 24px;">Magang GCS</span></div>
    <div id="map"></div>

    <button id="connection-button" class="absolute-button" onclick="toggleMenu('connection-menu')">Connection</button>
    <button id="hud-button" class="absolute-button" onclick="toggleMenu('hud-menu')">HUD</button>
    <button id="menu-button" class="absolute-button" onclick="toggleMenu('main-menu')">Menu</button>

    <div id="stats-menu">
        <table>
            <thead>
                <tr>
                    <th>Latitude</th>
                    <th>Longitude</th>
                    <th>HDOP</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td id="latitudeBottom">-6.9766594</td>
                    <td id="longitudeBottom">107.6303215</td>
                    <td>0.8</td>
                </tr>
            </tbody>
        </table>
    </div>

    <div id="connection-menu" class="floating-menu" style="display: none;">
        <div class="label">Stats</div>
        <input type="text" class="input-box" id="text-url" placeholder="Enter URL" onkeypress="handleKeyPress(event)">
        <button id="button-connect" onclick="connectServer()">Connect</button>
        <div class="label">Log</div>
        <textarea id="log-box" placeholder="Log Initializated" readonly style="height: 70%;"></textarea>
    </div>


    <div id="hud-menu" class="floating-menu" style="display: none;">
        <img id="cam" src="{{ url_for('video') }}">
        <table>
            <thead>
                <tr>
                    <th>Kecepatan</th>
                    <th>Ketinggian</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td id="uav-ground-speed">0</td>
                    <td id="uav-altitude">0</td>
                </tr>
            </tbody>
            <thead>
                <tr>
                    <th>Tujuan</th>
                    <th>Jarak</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>0</td>
                    <td id="uav-wp-dist">0</td>
                </tr>
            </tbody>
            <thead>
                <tr>
                    <th>Yaw</th>
                    <th>Pitch</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td id="uav-yaw">0</td>
                    <td id="uav-pitch">0</td>
                </tr>
            </tbody>
            <thead>
                <tr>
                    <th>Roll</th>
                    <th>AirSpeed</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td id="uav-roll">0</td>
                    <td id="uav-air-speed">0</td>
                </tr>
            </tbody>
            <tbody>
                <tr>
                    <td id="uav-mode">RTL</td>
                    <td id="uav-status">Disarmed</td>
                </tr>
            </tbody>
        </table>
    </div>

    <div id="main-menu" class="floating-menu" style="display: none;">
        <div>
            <canvas id="bearing-distance"></canvas>
            <canvas id="tracker-model"></canvas>
        </div>
        <div>
            <span>Bearing:</span>
            <span>Distance:</span>
        </div>
        <div>
            <span>Antenna Tracker </span>
            <span>Lat, Lon</span>
        </div>
        <div>
            <span>UAV </span>
            <span>Lat, Lon</span>
        </div>
        <div>
            <a href="https://icons8.com/icon/PfN95KmgejZB/uav">Uav</a> and <a
                href="https://icons8.com/icon/111536/antenna">Antenna</a> icon by <a
                href="https://icons8.com">Icons8</a>
        </div>
    </div>

    <script>
        startFetching("http://localhost:5000/rest/mavlink/");
        let fetchInterval;
        var trackerMarker = [-6.9766594, 107.6303215];
        var map = L.map('map', { zoomControl: false }).setView(trackerMarker, 18);

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: 'OpenStreetMap contributors'
        }).addTo(map);

        L.marker(trackerMarker)
            .addTo(map)
            .bindPopup('Antenna Tracker')
            .setIcon(L.icon({
                iconUrl: "https://img.icons8.com/pastel-glyph/64/gps-searching--v2.png",
                iconSize: [48, 48]
            }));

        var popup = L.popup();

        function onMapClick(e) {
            popup
                .setLatLng(e.latlng)
                .setContent("You clicked the map at " + e.latlng.toString())
                .openOn(map);
        }

        map.on('click', onMapClick);

        // function closeMenuOutsideClick(event) {
        //     const menu = document.getElementById('main-menu');
        //     const button = document.getElementById('menu-button');

        //     if (!menu.contains(event.target) && event.target !== button) {
        //         toggleMenu('main-menu');
        //     }
        // }

        function handleKeyPress(event) {
            if (event.key === 'Enter') {
                connectServer();
            }
        }

        function toggleMenu(menuId) {
            var menu = document.getElementById(menuId);
            // if (menuId === 'main-menu' && menu.style.display === 'block') {
            //     document.addEventListener('click', closeMenuOutsideClick);
            // } else {
            //     document.removeEventListener('click', closeMenuOutsideClick);
            // }
            if (menuId == 'main-menu') {
                menu.style.display = menu.style.display === 'none' ? 'flex' : 'none';
                var bearingDistCanvas = document.getElementById('bearing-distance');
                bearingDistCanvas.style.width = '300px';
                bearingDistCanvas.style.height = '300px';
                bearingDistCanvas.width = '300';
                bearingDistCanvas.height = '300';
                var modelCanvas = document.getElementById('tracker-model');
                modelCanvas.style.width = '300px';
                modelCanvas.style.height = '300px';
                modelCanvas.width = '300';
                modelCanvas.height = '300';
            } else {
                menu.style.display = menu.style.display === 'none' ? 'block' : 'none';
            }
        }

        document.getElementById('cam').onerror = function () {
            this.src = 'kucing.jpg';
        };

        let pointerLat;
        let pointerLng;
        map.on('mousemove', function (e) {
            pointerLat = e.latlng.lat.toFixed(5);
            pointerLng = e.latlng.lng.toFixed(5);
            document.getElementById('latitudeBottom').textContent = pointerLat;
            document.getElementById('longitudeBottom').textContent = pointerLng;
            var bearing = calculateBearing(trackerMarker[0], trackerMarker[1], pointerLat, pointerLng);
            drawIndicator(bearing);
            sendData(bearing);
        });

        function calculateBearing(lat1, lon1, lat2, lon2) {
            lat1 = toRadians(lat1);
            lon1 = toRadians(lon1);
            lat2 = toRadians(lat2);
            lon2 = toRadians(lon2);

            const dLon = lon2 - lon1;

            const y = Math.sin(dLon) * Math.cos(lat2);
            const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
            let bearing = Math.atan2(y, x);

            bearing = toDegrees(bearing);

            bearing = (bearing + 360) % 360;

            return bearing;
        }

        function toRadians(degrees) {
            return degrees * (Math.PI / 180);
        }

        function toDegrees(radians) {
            return radians * (180 / Math.PI);
        }

        let uavMarker;
        function parseMAVProxy(data) {
            var statusText = JSON.stringify(data.STATUSTEXT.text) + "\n";
            // var sysStatus = JSON.stringify(data.SYS_STATUS);
            // var powerStatus = JSON.stringify(data.POWER_STATUS);
            // var ekfStatus = JSON.stringify(data.EKF_STATUS_REPORT);
            // var batteryStatus = JSON.stringify(data.BATTERY_STATUS);

            var uavLat = parseInt(data.GLOBAL_POSITION_INT.lat) * 1.0e-7;
            var uavLng = parseInt(data.GLOBAL_POSITION_INT.lon) * 1.0e-7;
            uavMarker.setLatLng(L.latLng(uavLat, uavLng));

            // var bearing = calculateBearing(trackerMarker[0], trackerMarker[1], uavLat, uavLng);
            // drawIndicator(bearing);
            // drawSpeedometer(bearing);

            document.getElementById("log-box").value += statusText;
            document.getElementById("uav-ground-speed").innerText = parseFloat(data.VFR_HUD.groundspeed).toFixed(3);
            document.getElementById("uav-altitude").innerText = parseFloat(data.GLOBAL_POSITION_INT.relative_alt) * 1e-3;
            document.getElementById("uav-wp-dist").innerText = parseFloat(data.NAV_CONTROLLER_OUTPUT.wp_dist).toFixed(3);
            document.getElementById("uav-yaw").innerText = parseFloat(data.AHRS2.yaw).toFixed(3);
            document.getElementById("uav-pitch").innerText = parseFloat(data.AHRS2.pitch).toFixed(3);
            document.getElementById("uav-roll").innerText = parseFloat(data.AHRS2.roll).toFixed(3);
            document.getElementById("uav-air-speed").innerText = parseFloat(data.VFR_HUD.airspeed).toFixed(3);

            if (data.POSITION_TARGET_GLOBAL_INT) {
                // console.log("Moving to target!");
            }
        }

        function startFetching(url) {
            var textArea = document.getElementById("log-box");
            var button = document.getElementById('button-connect');
            button.style.backgroundColor = "#CCC";
            button.style.color = "#000";
            button.disabled = true;
            textArea.value += "Attempting to connect...\n";
            var disconnectedTimes = 0;
            var timeOut = 100;
            var retryTimes = 5;

            function keepFetching() {
                if (disconnectedTimes > retryTimes) {
                    console.log("Failed to connect, stopped retrying");
                    stopFetching();
                } else {
                    fetchInterval = setTimeout(fetchAndCheckConnection, timeOut);
                }
            }

            function fetchAndCheckConnection() {
                fetch(url)
                    .then(response => response.json())
                    .then(data => {
                        disconnectedTimes = 0;
                        if (!uavMarker) {
                            var lat = parseInt(data.GLOBAL_POSITION_INT.lat) * 1.0e-7;
                            var lon = parseInt(data.GLOBAL_POSITION_INT.lon) * 1.0e-7;
                            uavMarker = L.marker([lat, lon])
                                .addTo(map)
                                .setIcon(
                                    L.icon({
                                        iconUrl: 'https://img.icons8.com/external-flaticons-flat-flat-icons/64/external-uav-smart-technology-flaticons-flat-flat-icons.png',
                                        iconSize: [48, 48],
                                    }));
                        }
                        parseMAVProxy(data);
                        keepFetching();
                    })
                    .catch(() => {
                        disconnectedTimes++;
                        console.log("Cannot connect, retrying...");
                        keepFetching();
                    });
                textArea.scrollTop = textArea.scrollHeight;
            }

            fetchAndCheckConnection();
        }

        function stopFetching() {
            clearInterval(fetchInterval);

            document.getElementById("log-box").value += "Error or Disconnected!\n";

            var button = document.getElementById('button-connect');
            button.style.backgroundColor = "#007BFF";
            button.style.color = "#FFF";
            button.disabled = false;

            if (uavMarker) {
                map.removeLayer(uavMarker);
            }
            console.log('Fetching stopped.');
        }

        function connectServer() {
            var url = document.getElementById('text-url').value;
            startFetching(url);
        }

        // https://stackoverflow.com/questions/17537287/gauge-js-almost-full-circle
        var bearingCanvas = document.getElementById("bearing-distance");
        var bearingCtx = bearingCanvas.getContext("2d");
        var indicatorX = bearingCanvas.width / 2;
        var indicatorY = bearingCanvas.height;
        var indicatorBaseWidth = 20;
        var indicatorHeight = 120;
        var indicatorFill = "maroon";

        function drawIndicator(indicatorDegrees) {
            bearingCtx.clearRect(0, 0, bearingCanvas.width, bearingCanvas.height);
            bearingCtx.save();
            bearingCtx.translate(indicatorX, indicatorY);
            bearingCtx.rotate(indicatorDegrees * Math.PI / 180);
            bearingCtx.beginPath();
            bearingCtx.moveTo(-indicatorBaseWidth / 2, 0);
            bearingCtx.quadraticCurveTo(0, 10, indicatorBaseWidth / 2, 0);
            bearingCtx.lineTo(0, -indicatorHeight);
            bearingCtx.closePath();
            bearingCtx.strokeStyle = "gray";
            bearingCtx.lineWidth = 3;
            bearingCtx.stroke();
            bearingCtx.fillStyle = indicatorFill;
            bearingCtx.fill();
            bearingCtx.beginPath();
            bearingCtx.arc(0, 0, 3, 0, Math.PI * 2, false);
            bearingCtx.closePath();
            bearingCtx.fillStyle = "gold";
            bearingCtx.fill();
            bearingCtx.restore();
        }

        function drawSpeedometer(targetDegrees) {
            const canvas = document.getElementById('bearing-distance');
            const ctx = canvas.getContext('2d');

            // Clear the canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw the speedometer
            console.log(canvas.width, canvas.height);
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = 70;

            // Draw the outer circle
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw the target indicator
            const targetRadians = (targetDegrees - 90) * (Math.PI / 180);
            const targetX = centerX + radius * Math.cos(targetRadians);
            const targetY = centerY + radius * Math.sin(targetRadians);

            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(targetX, targetY);
            ctx.strokeStyle = '#FF0000';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw the inner circle
            ctx.beginPath();
            ctx.arc(centerX, centerY, 10, 0, 2 * Math.PI);
            ctx.fillStyle = '#000';
            ctx.fill();
        }

        const cubeCanvas = document.getElementById('tracker-model');
        const cubeCtx = cubeCanvas.getContext('2d');

        function rotatePoint(point, angleX, angleY, angleZ) {
            const cosX = Math.cos(angleX);
            const sinX = Math.sin(angleX);
            const cosY = Math.cos(angleY);
            const sinY = Math.sin(angleY);
            const cosZ = Math.cos(angleZ);
            const sinZ = Math.sin(angleZ);

            const x = point.x * cosY * cosZ - point.y * cosY * sinZ + point.z * sinY;
            const y = point.x * (cosX * sinZ + sinX * sinY * cosZ) +
                point.y * (cosX * cosZ - sinX * sinY * sinZ) -
                point.z * sinX * cosY;
            const z = point.x * (sinX * sinZ - cosX * sinY * cosZ) +
                point.y * (sinX * cosZ + cosX * sinY * sinZ) +
                point.z * cosX * cosY;

            return { x, y, z };
        }

        function drawCube(rotationX, rotationY, rotationZ) {
            cubeCtx.clearRect(0, 0, cubeCanvas.width, cubeCanvas.height);

            // Set cube dimensions
            const size = 100;

            // Define cube vertices
            const vertices = [
                { x: -size / 2, y: -size / 2, z: -size / 2 },
                { x: size / 2, y: -size / 2, z: -size / 2 },
                { x: size / 2, y: size / 2, z: -size / 2 },
                { x: -size / 2, y: size / 2, z: -size / 2 },
                { x: -size / 2, y: -size / 2, z: size / 2 },
                { x: size / 2, y: -size / 2, z: size / 2 },
                { x: size / 2, y: size / 2, z: size / 2 },
                { x: -size / 2, y: size / 2, z: size / 2 }
            ];

            // Define cube edges
            const edges = [
                [0, 1], [1, 2], [2, 3], [3, 0],
                [4, 5], [5, 6], [6, 7], [7, 4],
                [0, 4], [1, 5], [2, 6], [3, 7]
            ];

            // Rotate each vertex of the cube
            const rotatedVertices = vertices.map(vertex =>
                rotatePoint(vertex, rotationX, rotationY, rotationZ)
            );

            // Function to check if an edge belongs to the red side
            function isRedSideEdge(edge) {
                // For this example, let's consider the side defined by vertices 0, 1, 5, and 4 as the red side
                const redSideVertices = [0, 1, 5, 4];
                return redSideVertices.includes(edge[0]) && redSideVertices.includes(edge[1]);
            }

            // Connect the rotated vertices to draw the edges of the rotated cube
            edges.forEach(edge => {
                const startPoint = rotatedVertices[edge[0]];
                const endPoint = rotatedVertices[edge[1]];

                cubeCtx.beginPath();
                cubeCtx.moveTo(startPoint.x + cubeCanvas.width / 2, startPoint.y + cubeCanvas.height / 2);
                cubeCtx.lineTo(endPoint.x + cubeCanvas.width / 2, endPoint.y + cubeCanvas.height / 2);

                // Check if the edge belongs to the red side, and color it red
                if (isRedSideEdge(edge)) {
                    cubeCtx.strokeStyle = 'red';
                } else {
                    cubeCtx.strokeStyle = 'white';
                }

                cubeCtx.stroke();
            });
        }

        // Initial rotation angles
        let rotationX = 0;
        let rotationY = 0;
        let rotationZ = 0;

        function animate() {
            rotationX += 0.01;
            rotationY += 0.02;
            rotationZ += 0.03;

            drawCube(rotationX, rotationY, rotationZ);

            requestAnimationFrame(animate);
        }

        // Start the animation
        // animate();

        // function setBearingGauge() {
        //     drawIndicator(0);
        //     var bearingGauge = new Gauge(document.getElementById("bearing-distance"));
        //     var opts = {
        //         angle: -35,
        //         lineWidth: 0.2,
        //         radiusScale: 0.9,
        //         pointer: {
        //             length: 0.6,
        //             strokeWidth: 0.05,
        //             color: '#000000'
        //         },
        //     };
        //     bearingGauge.setOptions(opts);
        // }
        function sendData(ang) {
        var inputData = {
            angle: ang
        };
        fetch('/process_data', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(inputData),
        })
        .then(response => response.json())
        .then(data => {
            console.log('Response from Flask:', data);
        })
        .catch(error => {
            console.error('Error sending data to Flask:', error);
        });
    }
    </script>

</body>

</html>